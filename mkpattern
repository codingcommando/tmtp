#!/usr/bin/env python
#

# for the framework
from sys             import argv
from getopt          import getopt, GetoptError

# for the pattern generation
from tmtpl.utils     import stdo
from tmtpl.std_app   import StdApp

from tmtpl.constants import *
from tmtpl.pattern   import *
from tmtpl.document   import *
from tmtpl.support   import *
from tmtpl.client   import Client

# Project specific
#from math import sin, cos, radians

from pysvg.filter import *
from pysvg.gradient import *
from pysvg.linking import *
from pysvg.script import *
from pysvg.shape import *
from pysvg.structure import *
from pysvg.style import *
from pysvg.text import *
from pysvg.builders import *

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        if e != '': print e
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] --client=<client file> [--debug=[dump]] outfile \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --verbose        Give some feedback of what is happening while the script is         \n")
        stdo("                         running.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --config=<cfg file>                                                                  \n")
        stdo("                         The full path to the configuration file to use instead of           \n")
        stdo("                         the default location.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --client=<client file>                                                               \n")
        stdo("                         The full path to the client data file to use.                       \n")
        stdo("                                                                                             \n")
        stdo("        --debug=[dump]                                                                       \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --verbose out.svg                                                                 \n" % self.cfg['app_name'])

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'verbose', 'config=', 'client=', 'debug=']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            if len(args) != 1:
                raise CmdlineError('You must supply an output file name\n\n')
                
            self.cfg['args'] = args

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--verbose'):
                    self.cfg['verbose'] = True

                elif opt in ('--config'):
                    self.cfg['configuration_file'] = val

                elif opt in ('--client'):
                    self.cfg['client_file'] = val

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        # can add code here as needed
        return


# AppTemplate
#
class AppTemplate(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)
            return

        if self.cfg.has_key('verbose'):
            verbose = True
        else:
            verbose = False

        if self.cfg.has_key('client_file'):
            mfn = self.cfg['client_file']
            if verbose:
                print "Using client file: ", mfn
        else:
            cmdline.error('Error: You must specify a client file\n\n', self.defaults)
            return

        dbgdump = False
        if self.cfg.has_key('debug'):
            debug = self.cfg['debug']
            if "dump" in debug:
                dbgdump = True
                print "Debug: dump enabled"
        else:
            dbgdump = False

        # open the client file and read the data
        client = Client(self.cfg['client_file'])
        cd = client.data

        if dbgdump:
            print "========== Client Data Dump =========="
            print client.dump(),
            print "======== End Client Data Dump ========"

        # pattern name
        pattern_pieces    = 7

        # TODO also extract these from this file to somewhere else
        printer='36" wide carriage plotter'
        if (printer == '36" wide carriage plotter'):
            paper_width  = ( 36 * in_to_pt )
            border       = ( 1 * in_to_pt )        # 1" document borders


        # create the document info and fill it in
        # TODO - abstract these into configuration file(s)
        companyName = 'New Day'
        patternName = 'Steampunk Jacket'
        patternNumber = '1870-M-J-1'
        clientName = cd.customername

        # attributes for the entire svg document
        docattrs = {'currentScale' : "0.05 : 1",
                    'fitBoxtoViewport' : "True",
                    'preserveAspectRatio' : "xMidYMid meet",
                    'margin-bottom' : str(border),
                    'margin-left' : str(border),
                    'margin-right' : str(border),
                    'margin-top' : str(border),
                    'company-name' : companyName,
                    'pattern-number' : patternNumber,
                    'pattern-name' : patternName,
                    'client-name' : clientName
                    }

        doc = Document(self.cfg['args'][0], name = 'document', attributes = docattrs)

        # TODO also extract these from this file to somewhere else
        printer='36" wide carriage plotter'
        if (printer == '36" wide carriage plotter'):
            doc.paper_width  = paper_width
            doc.border       = border

        # Set up the title block
        tb = TitleBlock('pattern', 'titleblock', doc.border, doc.border, company_name = companyName, pattern_name = patternName, pattern_number = patternNumber, client_name = clientName)
        doc.add(tb)

        #
        # Begin the real work here
        #
        # svg constants TODO I think I removed the need for these
        #svgNameText = []
        #no_transform = ''   # no transform required



        # pattern start, count & placement
        x = border
        y = border

        begin = Point('reference', 'begin', x,   (y + PATTERN_OFFSET))
        doc.add(begin)

        # This was here, and used later to calculate doc size
        # TODO may not be needed
        #layout = Layout( 'layout',  begin.x,  begin.y,  reference_layer)

        # may not be needed??
        #docinfo.lowx = begin.x
        #docinfo.lowy = begin.y

        # The whole pattern in a jacket
        jacket = Pattern('jacket')
        doc.add(jacket)

        # Create the back pattern piece
        back = PatternPiece('pattern', 'back', letter = 'A', fabric = 2, interfacing = 0, lining = 0)
        jacket.add(back)

        jb = jacket.back

        start =  Point('reference', 'start', begin.x, begin.y)
        jb.add(start)

        jb.attrs['transform'] = 'translate(' + jb.start.coords + ' )'
        jb.add(Point('reference', 'low', 0, 0))
        jb.add(Point('reference', 'high', 0, 0))

        jb.width = max(cd.back.shoulder.width, cd.back.chest.width, cd.back.waist.width, cd.back.hip.width) \
            + (2*SEAM_ALLOWANCE) + (3*cm_to_pt)  # 3cm ease assumed
        jb.height = cd.back.neck.length + cd.back.jacket.length + HEM_ALLOWANCE + (2*SEAM_ALLOWANCE) + (3*cm_to_pt) #3cm ease assumed

        nape = Point('reference', 'nape', 0, 0)
        jb.add(nape)

        # reference back center seam points for nape, shoulder, chest, waist, hip, hem
        jb.add(Node('seam'))
        jb.seam.add(Node('center'))
        jb.seam.center.add(Point('reference', 'shoulder', jb.nape.x, jb.nape.y + cd.back.shoulder.length))
        jb.seam.center.add(Point('reference', 'chest', jb.nape.x + (1*cm_to_pt), jb.nape.y + cd.back.chest.length))
        jb.seam.center.add(Point('reference', 'waist', jb.nape.x + (2.5*cm_to_pt), jb.nape.y + cd.back.waist.length))
        jb.seam.center.add(Point('reference', 'hip', jb.nape.x + (2*cm_to_pt), jb.seam.center.waist.y + cd.back.hip.length))
        jb.seam.center.add(Point('reference', 'hem', jb.nape.x + (1.5*cm_to_pt), cd.back.jacket.length))
        jb.seam.center.add(Point('reference', 'hem_allowance', jb.seam.center.hem.x +0, jb.seam.center.hem.y + HEM_ALLOWANCE))

        # reference back side seam points for chest, waist, hip, hem
        jb.seam.add(Node('side'))
        jb.seam.side.add(Point('reference', 'chest', jb.nape.x + cd.back.shoulder.width - (1*cm_to_pt),  jb.nape.y + cd.back.chest.length))
        jb.seam.side.add(Point('reference', 'waist', jb.nape.x + cd.back.shoulder.width - (3*cm_to_pt),  jb.nape.y + cd.back.waist.length))
        jb.seam.side.add(Point('reference', 'hip', jb.nape.x + cd.back.shoulder.width - (2*cm_to_pt),  jb.seam.side.waist.y + cd.back.hip.length))
        jb.seam.side.add(Point('reference', 'hem', jb.nape.x + cd.back.shoulder.width - (1.5*cm_to_pt),   cd.back.jacket.length))
        jb.seam.side.add(Point('reference', 'hem_allowance', jb.seam.side.hem.x, jb.seam.side.hem.y + HEM_ALLOWANCE))

        # armscye points
        jb.add(Point('reference', 'balance', jb.nape.x + cd.back.shoulder.width,  jb.nape.y + cd.back.balance.length))
        jb.add(Point('reference', 'underarm', jb.nape.x + cd.back.shoulder.width, jb.nape.y + cd.back.balance.length + abs(cd.back.balance.length - cd.back.chest.length)*(.48)))

        # diagonal shoulder line
        jb.seam.add(Node('shoulder'))
        jb.seam.shoulder.add(Point('reference', 'high', jb.nape.x + cd.back.neck.width, jb.nape.y - cd.back.neck.length))
        jb.seam.shoulder.add(Point('reference', 'low', jb.seam.center.shoulder.x + cd.back.shoulder.width + (1*cm_to_pt), jb.seam.center.shoulder.y))

        # Back Vertical Reference Grid
        bgrid = Node('grid')
        jb.add(bgrid)
        bgrid.add(Line('reference', 'center', 'Jacket Back - Center', nape.x, nape.y, nape.x, nape.y +jb.height)) # vertical line
        bgrid.add(Line('reference', 'shoulderwidth', 'Jacket Back - Shoulder Width', nape.x + cd.back.shoulder.width, nape.y, nape.x + cd.back.shoulder.width, nape.y + jb.height))
        bgrid.add(Line('reference', 'side', 'Jacket Back - Side', nape.x + jb.width, nape.y, nape.x + jb.width, nape.y + jb.height))
        jbss = jb.seam.shoulder
        bgrid.add(Line('reference', 'neck', 'Jacket Back - Neck', jbss.high.x, jbss.high.y, jbss.high.x, jbss.high.y + cd.back.neck.length))

        # Back Horizontal Reference Grid
        bgrid.add(Line('reference', 'top', 'Jacket Back - Top', nape.x, nape.y, nape.x + jb.width, nape.y))
        bgrid.add(Line('reference', 'shoulder', 'Jacket Back - Shoulder', nape.x, jb.seam.center.shoulder.y, nape.x + jb.width, jb.seam.center.shoulder.y))
        bgrid.add(Line('reference', 'chest', 'Jacket Back - Chest', nape.x, jb.seam.center.chest.y, nape.x + jb.width, jb.seam.center.chest.y))
        bgrid.add(Line('reference', 'waist', 'Jacket Back - Waist', nape.x, jb.seam.center.waist.y, nape.x + jb.width, jb.seam.center.waist.y))
        bgrid.add(Line('reference', 'hip', 'Jacket Back - Hip', nape.x, jb.seam.center.hip.y, nape.x + jb.width, jb.seam.center.hip.y))
        bgrid.add(Line('reference', 'hem', 'Jacket Back - Hem', nape.x, jb.seam.center.hem.y, nape.x + jb.width, jb.seam.center.hem.y))
        bgrid.add(Line('reference', 'hem_allowance', 'Jacket Back - Hem Allowance', nape.x, jb.seam.center.hem_allowance.y, nape.x + jb.width, jb.seam.center.hem_allowance.y))
        bgrid.add(Line('reference', 'end', 'Jacket Back - End', nape.x, jb.nape.y + jb.height, nape.x + jb.width,  jb.nape.y + jb.height))

        # Back Center Seam line clockwise from bottom left:

        # Control Points
        distance = abs(jb.seam.center.hip.y - jb.seam.center.waist.y )*(.3)
        x, y = pointAlongLine(jb.seam.center.hip.x, jb.seam.center.hip.y, jb.seam.center.hem.x, jb.seam.center.hem.y, distance)
        jb.add(Point('reference', 'c1', x, y))
        jb.add(Point('reference', 'c2', jb.seam.center.waist.x, jb.seam.center.waist.y + abs(jb.seam.center.waist.y - jb.seam.center.hip.y) * (.3)))
        jb.add(Point('reference', 'c3', jb.seam.center.waist.x, jb.seam.center.waist.y - abs(jb.seam.center.waist.y - jb.seam.center.chest.y) * (.3)))

        distance = abs( jb.seam.center.chest.y - jb.seam.center.waist.y )*(.3)
        x, y = pointAlongLine(jb.seam.center.chest.x, jb.seam.center.chest.y, jb.seam.center.shoulder.x, jb.seam.center.shoulder.y, distance)
        jb.add(Point('reference', 'c4', x, y))
        jb.add(Point('reference', 'c5', jb.seam.center.chest.x - abs(jb.seam.center.chest.x - jb.seam.center.shoulder.x)*(.3),
                     jb.seam.center.chest.y - abs( jb.seam.center.chest.y - jb.seam.center.shoulder.y )*(.3)))
        jb.add(Point('reference', 'c6', jb.seam.center.shoulder.x, jb.seam.center.shoulder.y + abs( jb.seam.center.shoulder.y - jb.seam.center.chest.y )*(.3)))

        # Back Center Seam path
        #   jb.seam.center.path  = 'L '+ jb.seam.center.hem_allowance.coords +' L '+  jb.seam.center.hem.coords + ' L ' +  jb.seam.center.hip.coords +' C '+ c1.coords +' '+ c2.coords +' '+ jb.seam.center.waist.coords +' C '+ c3.coords +' '+ c4.coords +' '+ jb.seam.center.chest.coords +' C '+ c5.coords +' '+ c6.coords + ' '+ jb.seam.center.shoulder.coords +' L '+ jb.nape.coords


        #
        # Temporary End
        #
        doc.draw()
        return

        jb.seam.add(Node('neck'))
        jb.seam.add(Node('armhole'))
        jb.seam.add(Node('hem'))


        #
        # Temporary End
        #
        doc.draw()
        return




        # create a pattern part

        # and the first piece in the jacket is the back

        grainline = Path('grainline', 0, 0)
        jb.add(grainline)

        center_seam = Path('center_seam', arg2, points=['shoulder', 'chest', 'waist', 'hip', 'hem'])
        jacket.add(center_seam)

        side_seam = Path()
        shoulder_seam = Path()
        # add path obj to pattern piece
        # grainline.path
        # seam.center.path
        # seam.side.path
        # seam.shoulder.path
        jb.seam.neck = Generic() # uses seam.neck.path
        jb.seam.armhole = Generic() # seam.armhole.path
        jb.seam.hem = Generic() # seam.hem.path



        #
        # End of experiments
        #
        doc.draw()
        return

        oh = ShapeBuilder()

        # use an incrementing counter to set element IDs
        idcount = 0

        # draw 24 hour markers like a clock face
        for hour in range (0, 24):
            ang = (hour + tz) * 15
            tx, ty = polar2Rect(timelength, ang-90)
            sz.addElement(oh.createLine(xoff, yoff, xoff + tx, yoff + ty, strokewidth=2, stroke="lightgray"))

            tx, ty = polar2Rect(timetextlen, ang-90)
            dh = hour - 6
            if dh < 0:
                dh = dh + 24
            tt = str(dh)
            t = text(tt, tx + xoff, ty + yoff)
            sz.addElement(t)

        # Draw the text element for use with mouse events
        t = text("text box", xoff, 20)
        t.set_id("textNode")
        sz.addElement(t)

        # Draw the QSO points
        recs = adifParse(self.cfg['args'][0])
        for rec in recs:
            
            if (dumprecords):
                print rec

            call = rec["call"]
            if not rec.has_key('gridsquare'):
                if (verbose):
                    print "skipping (no grid) " + call
                continue

            if isUSCall(call):
                if (verbose):
                    print "skipping (US) " + call
                continue

            angle = angleFromTime(rec["time_on"]) + (tz * 15)
            distance, azimuth = bearingDistance(rec["my_gridsquare"], rec["gridsquare"])
            distance = distance / scale

            bx, by = polar2Rect(distance, angle-90)
            fillcolor = freq2Color(rec["freq"])

            eid = str(idcount)
            idcount = idcount + 1

            #poptext = rec["call"] + " " + str(rec["freq"])
            dot = circle(bx + xoff, by + yoff, dotsize)
            # appearance
            dot.set_fill(fillcolor)
            dot.set_stroke('black')
            # attributes and such
            dot.set_id(eid)
            dot.setAttribute("call", call)
            dot.setAttribute("freq", rec['freq'])
            dot.setAttribute("time", rec['time_on'])
            dot.setAttribute("date", rec['qso_date'])

            # events
            #dot.set_onmouseover('showQSO(evt)')
            #dot.set_onmouseout('hideQSO(evt)')
            #dot.set_onclick('QSOClick("' + rec["call"] + '")')

            sz.addElement(dot)

        sz.save("./testout.svg")


        return

if __name__ == '__main__':
    app = AppTemplate()
    app.main()

# vi:set ts=4 sw=4 expandtab:

